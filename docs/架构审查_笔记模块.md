# 笔记模块架构审查报告

**审查范围**：仅笔记相关功能（不含任务管理、思维笔记）  
**视角**：架构师  
**日期**：2025-02

---

## 一、模块边界与涉及文件

### 1.1 路由与入口

| 路径 | 说明 |
|------|------|
| `src/app/dashboard/page.tsx` | 仪表盘：文件夹/笔记列表切换、全局搜索、URL 参数处理 |
| `src/app/notes/[id]/page.tsx` | 公开阅读页：按 id 或 title 查笔记、反链、站内搜索高亮 |

### 1.2 核心 UI 组件

| 文件 | 职责 | 规模（约） |
|------|------|------------|
| `NoteManager.tsx` | 笔记模块编排：列表/编辑视图切换、数据拉取、保存/Realtime/离线协作 | **2100+ 行** |
| `NoteEditor.tsx` | 编辑视图：标题/标签、SegmentedEditor、预览、版本、工具栏、补全 UI | **1000+ 行** |
| `NoteList.tsx` | 列表视图：卡片/多选/拖拽/Dock/子文件夹入口 | **600+ 行** |
| `SegmentedEditor.tsx` | 分段编辑器（文本段 + 表格段）、浮动工具栏 | **1260+ 行** |
| `FolderManager.tsx` | 根级文件夹列表、创建/重命名/移动/删除、拖拽 | **560+ 行** |

### 1.3 支撑组件与工具

| 类型 | 文件 | 说明 |
|------|------|------|
| 编辑器相关 | `FloatingToolbar.tsx` | 选中文本格式化 |
| | `FindReplaceDialog.tsx` | 查找替换（依赖 `search-utils`） |
| | `TableEditor.tsx` / `InlineTableEditor.tsx` / `HybridEditor.tsx` | 表格/混合编辑（NoteManager 中未直接使用，SegmentedEditor 独立完成表格） |
| 展示 | `MarkdownRenderer.tsx` | 预览与只读渲染 |
| 数据/业务 | `version-history.ts` | 版本历史（note_versions 表） |
| | `offline-storage.ts` | 离线待同步队列（localforage） |
| | `export-utils.ts` / `ExportDialog.tsx` | 导出 ZIP |
| | `search-utils.ts` | 查找/替换/高亮 |
| | `table-utils.ts` | 表格解析与 Markdown 互转 |
| 统计 | `NoteStats.tsx` | 字数/段落/阅读时间 |
| | `stats.ts` | 仪表盘统计（含笔记相关） |

### 1.4 数据与后端

- **存储**：Supabase（PostgreSQL）
- **表**：`notes`（主表）、`note_versions`、`folders`
- **笔记 CRUD**：已抽象为独立服务层 `src/lib/note-service.ts`；并通过 `NoteServiceError` 统一错误语义（含 operation）。

---

## 二、架构结论（优点）

### 2.1 功能闭环完整

- 列表 ↔ 编辑 ↔ 保存（含防抖、重试、离线、Realtime 防误刷）形成闭环。
- 文件夹、回收站、置顶、发布、标签、版本历史、导出、[[ 链接 ]] 与标签补全等均有实现。

### 2.2 编辑与同步体验考虑较全

- 自动保存（1s 防抖）、保存状态展示、失败重试（最多 3 次）、网络错误时写入离线队列并在恢复后同步。
- Realtime 订阅当前笔记，通过指纹与时间窗口过滤“自更新”，再提示云端更新并支持自动拉取，逻辑清晰。

### 2.3 工具库边界清晰

- `search-utils`、`table-utils`、`version-history`、`offline-storage` 为纯函数或独立模块，便于单测与复用。

### 2.4 路由与入口职责明确

- Dashboard 负责鉴权、文件夹/笔记视图切换、全局搜索与 URL 参数；`notes/[id]` 专注公开阅读与反链，与编辑解耦。

---

## 三、架构问题与风险

### 3.1 笔记领域缺少统一服务层（高）

- **现状（已改进）**：notes 的增删改查已统一收敛到 `src/lib/note-service.ts`（`getNotes/searchNotes/getNoteByIdOrTitle/...`），UI 层不再直接散落调用 `supabase.from('notes')`。
- **影响**：
  - 表结构或 API 变更需改多处，易遗漏。
  - 无法集中做错误处理、重试、日志与监控。
  - 难以做统一的缓存或乐观更新策略。
- **建议（已落地）**：在 note-service 层统一抛出 `NoteServiceError`（含 `operation`），便于上层做 Toast/重试/埋点；离线“待同步”仍由上层协调（保持边界清晰）。

### 3.2 NoteManager 单文件过大（高）

- **现状**：单文件约 **3700+ 行**，同时承担：
  - 列表态：卡片、多选、拖拽、Dock 操作、筛选、子文件夹入口。
  - 编辑态：标题/内容/标签、SegmentedEditor、预览、禅模式、查找替换、表格插入、图片粘贴、版本历史、撤回、Realtime、离线、保存与重试。
- **影响**：可读性差、协作冲突多、单测难写、局部修改易引入回归。
- **建议**：
  - 按**视图**拆分：如 `NoteList.tsx`（列表 + 卡片 + 拖拽 + Dock）、`NoteEditor.tsx`（编辑区 + 标题/标签/ SegmentedEditor/预览/工具栏）。
  - 或将“保存与同步”抽成自定义 Hook（如 `useNoteSave`），Realtime 与离线逻辑放入 Hook 或独立模块。

### 3.3 笔记类型定义分散（中）

- **现状**：`Note` 或等价结构在 `notes/[id]/page.tsx`、`ExportDialog.tsx` 等处各自定义，字段不完全一致；`NoteManager` 大量使用 `any` 或局部类型。
- **影响**：类型不统一，重构和接口变更成本高。
- **建议**：在 `src/types/note.ts`（或 `src/lib/note-types.ts`）中统一定义 `Note`、`NoteCreate`、`NoteUpdate` 等，全项目引用；若引入 note-service，可由该层导出与 DB 映射的类型。

### 3.4 SegmentedEditor 与 NoteManager 耦合方式（中）

- **现状（已改进）**：内容变更仍通过 `onChange(content)` 上报；但 `[[ 链接 ]]` / `# 标签` 的检测、候选与键盘导航已抽离为 `useLinkComplete` / `useTagComplete`，并由 `NoteEditor` 统一渲染补全 UI。
- **影响**：补全与插入逻辑与列表/保存等混在一起，不利于将“编辑器+补全”单独复用或测试。
- **建议**：可考虑将“[[ 链接 ]] / # 标签”的检测与插入封装在 SegmentedEditor 内部或独立的 `useLinkComplete` / `useTagComplete` Hook，NoteManager 只消费“最终内容”与可选的回调（如插入后滚动到某位置）。

### 3.5 编辑器数据流与状态来源（中）

- **现状**：编辑态下 `title` / `content` / `tags` 等由 NoteManager 的 useState 持有，SegmentedEditor 受控于 `content`；保存时再写回 Supabase。多端/Realtime 更新时通过 `setCloudUpdateNote` + `handleAutoSyncFromCloud` 覆盖本地状态。
- **影响**：状态单一来源清晰，但“当前编辑内容”与“服务器权威值”的冲突策略（例如 last-write-wins 与版本历史的关系）分散在保存与 Realtime 两处，长期可读性一般。
- **建议**：在文档或注释中明确“编辑态以本地 state 为准，保存/拉云端后以服务器为准”；若未来做协同编辑，需要在这一层引入更明确的一致性模型。

### 3.6 全局搜索与笔记列表的重复查询（低）

- **现状**：Dashboard 的 `performSearch` 直接查 `notes` 表（title/content/tags）；进入文件夹后 NoteManager 的 `fetchNotes` 再按 folder_id 查一次。两处逻辑独立，无共享缓存。
- **影响**：从搜索结果点进某笔记时，会先带 noteId（+ 可选 folderId）再进入 NoteManager，由 `initialNoteId` 打开对应笔记，流程正确；仅在高频切换“搜索 ↔ 文件夹”时存在重复请求。
- **建议**：若后续优化性能，可考虑统一的笔记查询 Hook 或轻量缓存（按 user_id + folder_id / search 做 key），避免重复拉取同一视图数据。

---

## 四、依赖与数据流简图

```
dashboard/page
  ├── 鉴权、URL 参数、全局搜索（note-service.searchNotes）
  ├── FolderManager（根文件夹）→ onEnterFolder → 进入某文件夹
  └── NoteManager（folderId, initialNoteId）
        ├── fetchNotes / fetchSubFolders（note-service.getNotes + folders 表）
        ├── 列表：NoteList（卡片/Dock/多选/拖拽/回收站/子文件夹入口）
        └── 编辑：NoteEditor（title/content/tags state）
              ├── SegmentedEditor(content, onChange)
              ├── useLinkComplete / useTagComplete（补全逻辑）
              ├── useNoteSave（保存/离线/重试/版本协作）
              ├── useNoteRealtime（Realtime 自更新过滤 + 云端更新处理）
              └── MarkdownRenderer（预览）、FindReplaceDialog、NoteStats
```

---

## 五、改进优先级建议

| 优先级 | 项 | 预期收益 |
|--------|----|----------|
| P0 | 抽 note 服务层（note-service / note-storage） | 可维护性、一致性、后续扩展 |
| P0 | 拆分 NoteManager（列表视图 / 编辑视图 或 Hook） | 可读性、可测性、并行开发 |
| P1 | 统一 Note 类型定义并减少 any | 类型安全、重构成本 |
| P1 | 链接/标签补全与 NoteManager 解耦（可选） | 编辑器复用、单测 |
| P2 | 搜索与列表的查询复用或缓存（可选） | 性能与体验 |

---

## 六、总结

笔记模块功能完整、编辑与同步体验考虑较周全，工具库划分清晰。主要架构短板在于：**缺少笔记领域统一服务层**、**NoteManager 单文件过重**、**笔记类型定义分散**。建议优先增加 note 服务层并拆分 NoteManager，再逐步统一类型与补全逻辑，为后续功能（如协同、更多端）留出清晰边界。

---

## 七、具体任务拆解（对应 3.1–3.5）

以下任务由第三节「架构问题与风险」中的 3.1–3.5 拆解而来，按依赖顺序排列。

**执行状态（已在本轮完成）**：Task 3.2.1（useNoteSave）、Task 3.2.2（useNoteRealtime）、Task 3.2.3（NoteList）、Task 3.2.4（NoteEditor）、Task 3.2.5（收敛 NoteManager）、Task 3.3.3（笔记类型 any→Note）、Task 3.4.1（链接补全抽离 useLinkComplete）、Task 3.4.2（标签补全抽离 useTagComplete）、Task 3.4.3（补全 UI 归属统一：集中到 NoteEditor）、Task 3.5.2（保存/Realtime 路径注释）、Task 3.1.6（note-service 错误处理：NoteServiceError）。待续：无（本报告任务已清空）。

### 3.1 笔记领域缺少统一服务层 → 任务拆解

| 任务 ID | 任务内容 | 优先级 | 预估 | 依赖 |
|---------|----------|--------|------|------|
| **Task 3.1.1** | 新增 `src/lib/note-service.ts`，定义并导出：`getNotes(userId, options?)`（支持 folder_id、is_deleted、排序）、`getNoteById(id, userId)`、`createNote(data)`、`updateNote(id, userId, data)`、`deleteNote(id, userId)`、`moveNoteToFolder(id, userId, folder_id)`、`setNotesDeleted(ids, userId, is_deleted)`、`setNotesPinned(ids, userId, is_pinned)`。内部统一使用 `supabase.from('notes')`，对外只暴露 Promise 接口。 | P0 | 4–6h | 无 |
| **Task 3.1.2** | 将 `NoteManager` 中所有直接调用 `supabase.from('notes')` 的代码改为调用 note-service 的对应方法（fetchNotes、保存、删除、移动、置顶、软删除/恢复等）。 | P0 | 2–3h | 3.1.1 |
| **Task 3.1.3** | 将 `src/app/dashboard/page.tsx` 中笔记相关查询（如按 noteId 查 folder_id、全局搜索 performSearch）改为通过 note-service 或 note-service 提供的搜索方法。 | P0 | 1h | 3.1.1 |
| **Task 3.1.4** | 将 `src/app/notes/[id]/page.tsx` 中按 id/title 查询笔记的逻辑改为调用 note-service（可新增 `getNoteByIdOrTitle(idOrTitle, userId?)` 或保持只读查询在 service 中封装）。 | P1 | 0.5h | 3.1.1 |
| **Task 3.1.5** | 将 `ExportDialog`、`FolderManager`（移动笔记到文件夹时的 notes 更新）、`stats` 中与 notes 表相关的查询/更新改为调用 note-service。 | P1 | 1–2h | 3.1.1 |
| **Task 3.1.6** | 在 note-service 层统一处理可复用的错误提示与重试（可选）；与 `offline-storage` 的协调保留在 NoteManager 或上层，或在本层提供「在线则写 Supabase，离线则返回需待同步」的封装。 | P2 | 2h | 3.1.2 |

---

### 3.2 NoteManager 单文件过大 → 任务拆解

| 任务 ID | 任务内容 | 优先级 | 预估 | 依赖 |
|---------|----------|--------|------|------|
| **Task 3.2.1** | 抽取「保存与同步」逻辑为自定义 Hook：新建 `src/hooks/useNoteSave.ts`，职责包括：接收 currentNote、title、content、tags、isPinned、isPublished；内部封装防抖、saveNote 调用、重试、离线写入、与 version-history 的协作；返回 `{ save, saveStatus, retry }`。NoteManager 中删除原有 saveNote 内联实现，改为使用该 Hook。 | P0 | 3–4h | 建议在 3.1.2 之后 |
| **Task 3.2.2** | 抽取 Realtime 订阅与云端更新处理为 Hook 或独立模块：新建 `src/hooks/useNoteRealtime.ts`（或 `src/lib/note-realtime.ts`），职责包括：订阅当前 note.id 的 UPDATE、自更新过滤（指纹/时间窗口）、回调「收到云端更新」时由 NoteManager 调用 handleAutoSyncFromCloud。NoteManager 只负责将 setCloudUpdateNote 与处理函数传入。 | P0 | 2–3h | 3.2.1 可选 |
| **Task 3.2.3** | 按视图拆分 UI 组件：新建 `NoteList.tsx`，包含列表态下的笔记卡片列表、多选、拖拽、Dock、筛选、子文件夹入口、回收站切换等；NoteManager 在 view===’list’ 时渲染 `<NoteList ... />` 并传入 notes、handlers、状态。 | P0 | 4–5h | 无 |
| **Task 3.2.4** | 新建 `NoteEditor.tsx`，包含编辑态下的标题输入、标签、SegmentedEditor、预览/禅模式、工具栏（查找替换、表格插入、图片粘贴等）、版本历史入口、撤回。NoteManager 在 view===’editor’ 时渲染 `<NoteEditor ... />`，通过 props 传入 title/content/tags 与 onChange/handlers；保存与 Realtime 可由 useNoteSave / useNoteRealtime 在 NoteManager 中协调后通过 props 传入。 | P0 | 4–6h | 3.2.3 |
| **Task 3.2.5** | 将 NoteManager 收敛为：路由级状态（view、currentFolder 等）、fetchNotes/fetchSubFolders、useNoteSave/useNoteRealtime、NoteList/NoteEditor 的编排与回调；删除已迁移到 Hook 或子组件的代码，目标单文件控制在约 800 行以内。 | P0 | 2h | 3.2.1–3.2.4 |

---

### 3.3 笔记类型定义分散 → 任务拆解

| 任务 ID | 任务内容 | 优先级 | 预估 | 依赖 |
|---------|----------|--------|------|------|
| **Task 3.3.1** | 新建 `src/types/note.ts`（或 `src/lib/note-types.ts`），定义并导出：`Note`（与 notes 表字段对齐：id, user_id, folder_id, title, content, tags, is_pinned, is_published, is_deleted, created_at, updated_at 等）、`NoteCreate`、`NoteUpdate`（Partial 或显式可更新字段）。若先做 3.1，可由 note-service 再导出或 re-export 这些类型。 | P1 | 0.5h | 无 |
| **Task 3.3.2** | 将 `notes/[id]/page.tsx`、`ExportDialog.tsx` 中的本地 `Note` 或等价 interface 删除，改为从 `@/types/note` 导入；按需使用 `Note` 或 `Pick<Note, ...>`。 | P1 | 0.5h | 3.3.1 |
| **Task 3.3.3** | 在 NoteManager（及拆分后的 NoteList/NoteEditor）中，将笔记相关 state 与 props 的类型从 `any` 改为 `Note` 或 `Note \| null`；对事件回调和 API 返回值补充类型。 | P1 | 1–2h | 3.3.1 |

---

### 3.4 SegmentedEditor 与 NoteManager 耦合方式 → 任务拆解

| 任务 ID | 任务内容 | 优先级 | 预估 | 依赖 |
|---------|----------|--------|------|------|
| **Task 3.4.1** | 将「[[ 链接 ]] 检测与补全」逻辑从 NoteManager 抽离：新建 `useLinkComplete(content, cursorPosition?)` 或把逻辑内聚到 SegmentedEditor。Hook/内部逻辑负责：检测最后一个未闭合的 `[[`、维护补全列表与选中项、返回 `{ open, query, insertStart, onSelect }`；插入时通过回调把最终 content 或 delta 交给父组件。NoteManager 只接收 SegmentedEditor 的 onChange(content)，不再维护 linkMenuOpen/linkInsertStart/linkQuery 等状态（或仅保留 UI 展示用的最小状态）。 | P1 | 2–3h | 无 |
| **Task 3.4.2** | 将「# 标签检测与补全」以同样方式抽离为 `useTagComplete` 或并入 SegmentedEditor 内部；NoteManager 只消费最终内容与可选回调。 | P1 | 1–2h | 3.4.1 |
| **Task 3.4.3** | 若补全 UI（下拉列表、选中项）仍由 NoteManager 渲染，则通过 SegmentedEditor 的 props 或 context 传入「补全数据 + onSelect」；若希望编辑器完全自包含，可将补全 UI 移入 SegmentedEditor。统一后便于单独为「编辑器+补全」写单测或复用。 | P2 | 2h | 3.4.1–3.4.2 |

---

### 3.5 编辑器数据流与状态来源 → 任务拆解

| 任务 ID | 任务内容 | 优先级 | 预估 | 依赖 |
|---------|----------|--------|------|------|
| **Task 3.5.1** | 在 `NoteManager` 或 `NoteEditor` 顶部添加数据流说明注释（或链接到内部文档）：明确「编辑态以本地 state 为准；保存成功后以服务器返回为准；Realtime 收到他人/他端更新后经用户确认或自动拉取，以服务器为准覆盖本地」；注明 last-write-wins 与版本历史的关系（例如：保存即写表并写版本历史，冲突时以当前服务器版本为基准）。 | P1 | 0.5h | 无 |
| **Task 3.5.2** | 在 `useNoteSave`（若已实现）或保存/Realtime 处理函数处，补充简短注释：保存路径（防抖 → 在线/离线 → 成功/重试）、Realtime 路径（收包 → 自更新过滤 → 云端更新处理），便于后续做协同编辑时在此层引入一致性模型。 | P2 | 0.5h | 3.2.1 |

---

### 任务依赖关系简图

```
3.1.1 → 3.1.2, 3.1.3, 3.1.4, 3.1.5, 3.1.6
3.1.2 → 3.2.1
3.2.1 → 3.2.2(可选), 3.2.5
3.2.3, 3.2.4 → 3.2.5
3.3.1 → 3.3.2, 3.3.3
3.4.1 → 3.4.2 → 3.4.3
3.2.1 → 3.5.2
```

---

## 八、剩余任务建议执行优先级

以下为**尚未实现**的任务，按建议顺序执行可减少返工、便于协作与单测。

| 顺序 | 任务 | 理由 |
|------|------|------|
| **1** | **Task 3.2.1** useNoteSave | 先抽保存逻辑，NoteManager 立刻减重一大块，且为 3.2.2、3.2.5 打基础；与现有 note-service 配合清晰。 |
| **2** | **Task 3.2.2** useNoteRealtime | 再抽 Realtime/云端更新，与 3.2.1 一起把「数据与同步」从 UI 中剥离，后续改 UI 更安全。 |
| **3** | **Task 3.2.3** NoteList | 先拆列表视图（卡片、多选、拖拽、Dock、回收站），体量大、边界清晰，拆完再动编辑态。 |
| **4** | **Task 3.2.4** NoteEditor | 再拆编辑态（标题/标签/SegmentedEditor/预览/工具栏/版本/撤回），由 NoteManager 通过 props 传入保存与 Realtime 能力。 |
| **5** | **Task 3.2.5** 收敛 NoteManager | 在 3.2.3、3.2.4 完成后做编排与删冗余，目标约 800 行内。 |
| **6** | **Task 3.3.3** 笔记 state/props 改为 Note 类型 | 拆完再在 NoteList/NoteEditor/NoteManager 里把 `any` 换成 `Note`，改动范围更小、冲突更少。 |
| **7** | **Task 3.4.1** 链接补全抽离（useLinkComplete 或内聚到 SegmentedEditor） | 提升编辑器可复用与可测性，与 3.2 无强依赖，可并行或稍后做。 |
| **8** | **Task 3.4.2** 标签补全抽离（useTagComplete） | 依赖 3.4.1 的补全模式，放在其后。 |
| **9** | **Task 3.5.2** useNoteSave/Realtime 处注释 | 3.2.1、3.2.2 实现后顺手补充「保存路径 / Realtime 路径」注释即可。 |
| **10** | **Task 3.4.3** 补全 UI 归属统一 | 在 3.4.1、3.4.2 之后决定补全 UI 放在 NoteManager 还是 SegmentedEditor，便于单测与复用。 |
| **11** | **Task 3.1.6** note-service 层错误处理/重试（可选） | 架构稳定后再做；若当前 Toast/重试已在 NoteManager 满足需求，可长期 P3。 |

**简要结论**：优先做完 **3.2.1 → 3.2.2 → 3.2.3 → 3.2.4 → 3.2.5**（NoteManager 瘦身与拆分），再做 **3.3.3**（类型收紧）和 **3.4 / 3.5.2**（补全解耦与注释）；**3.1.6** 视需要放在最后或不做。
