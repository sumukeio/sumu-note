# 表格编辑器重构方案

## 问题分析

### 当前问题
1. **光标瞬移问题**：编辑表格时，光标会瞬移到笔记末尾
   - 原因：`InlineTableEditor` 的 `onUpdate` 更新整个内容后，`Textarea` 重新渲染导致光标位置丢失
   
2. **React 错误 #300**：hooks 调用顺序问题
   - 原因：早期返回在 hooks 之前，导致 hooks 数量不一致

3. **用户体验问题**：需要点击表格才出现可视化编辑器，不够直观

## 新方案：分段编辑器（SegmentedEditor）

### 核心思路
将 Markdown 内容解析为**文本段**和**表格段**：
- **文本段**：使用 `Textarea` 组件，保持原有的文本编辑体验
- **表格段**：直接渲染为 HTML `<table>`，使用 `<input>` 编辑单元格

### 实现细节

1. **内容解析**
   - 逐行扫描 Markdown 内容
   - 检测表格行（以 `|` 开头和结尾）
   - 将表格部分解析为二维数组 `string[][]`
   - 其他部分保持为文本

2. **渲染方式**
   - 文本段：使用 `Textarea` 组件
   - 表格段：使用 HTML `<table>` + `<input>` 单元格
   - 段之间用空行分隔

3. **内容同步**
   - 文本段编辑：直接更新对应段的 `content`
   - 表格段编辑：更新 `tableData`，然后转换为 Markdown
   - 所有段合并后调用 `onChange` 更新父组件

### 优势

1. ✅ **解决光标瞬移问题**
   - 表格编辑不触发整个内容更新
   - 文本段和表格段独立管理，互不影响

2. ✅ **解决 React 错误 #300**
   - 所有 hooks 在组件顶部统一调用
   - 没有条件性的早期返回

3. ✅ **更好的用户体验**
   - 表格直接显示为可视化表格，无需点击
   - 插入表格就是插入一个实实在在的二维表

4. ✅ **保持兼容性**
   - 底层仍使用 Markdown 格式存储
   - 预览和导出功能不受影响

### 潜在问题和解决方案

#### 问题1：多个 Textarea 导致光标管理复杂
**解决方案**：
- 每个文本段使用独立的 `Textarea`
- 光标位置由浏览器自动管理，不需要手动维护
- 段之间用空行分隔，视觉上清晰

#### 问题2：表格和文本之间的切换
**解决方案**：
- 表格前后自动添加空行
- 用户可以在表格前后的文本段中继续编辑
- 如果需要插入新内容，可以在相邻的文本段中编辑

#### 问题3：性能问题（大量表格时）
**解决方案**：
- 使用 `useMemo` 缓存解析结果
- 只在内容变化时重新解析
- 表格编辑使用防抖更新

#### 问题4：表格编辑时失去焦点
**解决方案**：
- 表格单元格使用 `<input>`，焦点管理由浏览器处理
- 编辑时不会触发整个组件重新渲染

### 使用方式

```tsx
<SegmentedEditor
  content={content}
  onChange={(newContent) => {
    setContent(newContent);
    handleContentChange(title, newContent);
  }}
  placeholder="开始输入内容..."
  className="..."
/>
```

### 迁移计划

1. **阶段1**：创建 `SegmentedEditor` 组件 ✅
2. **阶段2**：在 `NoteManager` 中集成（可选，通过配置切换）
3. **阶段3**：测试和优化
4. **阶段4**：替换原有的 `InlineTableEditor` 实现

## 替代方案对比

### 方案A：当前方案（InlineTableEditor）
- ❌ 光标瞬移问题
- ❌ React hooks 错误
- ✅ 保持单个 Textarea

### 方案B：SegmentedEditor（推荐）
- ✅ 解决光标瞬移
- ✅ 解决 React 错误
- ✅ 表格直接可视化
- ⚠️ 多个 Textarea（但用户体验更好）

### 方案C：ContentEditable 混合编辑器
- ✅ 单个编辑区域
- ❌ 实现复杂
- ❌ 光标管理困难
- ❌ 兼容性问题

## 结论

**推荐使用 SegmentedEditor 方案**，因为：
1. 彻底解决光标瞬移问题
2. 解决 React hooks 错误
3. 提供更好的用户体验（表格直接可视化）
4. 实现相对简单，风险可控
5. 保持 Markdown 兼容性
